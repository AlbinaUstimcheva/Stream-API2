#  Задача 2: Перепись населения

##  Описание
В этой задаче взят массив данных с информационными устройствами людей с использованием стримов из Stream API .

Для работы необходимо подготовить несколько классов, а именно:
1.  «Секс» , несколько типов полов:
```java
общественное  перечисление  Sex {
    МУЖЧИНА ,
    ЖЕНЩИНА
}
```
2.  «Образование» , различных типов образования:
```java
общественное  перечисление  Образование {
    ЭЛЕМЕНТАРНЫЙ ,
    ВТОРИЧНЫЙ ,
    ДАЛЬШЕ ,
    ВЫШЕ
}
```
3.  «Человек» , описывающий информацию об имени, возрасте, поле и образовании человека:
```java
класс  человек {
    частное  строковое имя;
    частная  семья String ;
    частный  целочисленный возраст;
    личный  секс секс;
    частное  образование образование;
    общественное  лицо ( имя строки  , семья строки , возраст , пол , образование , образование ) {    
        это . имя = имя;
        это . семья = семья;
        это . возраст = возраст;
        это . секс = секс;
        это . образование = образование;
    }
    публичная  строка  getName () {
        вернуть имя;
    }
    общественная  строка  getFamily () {
        вернуть семью;
    }
    общественное  целое  getAge () {
        возвратный возраст;
    }
    публичный  секс  getSex () {
        ответный секс;
    }
    государственное  образование  getEducation () {
        вернуть образование;
    }
    @Override
    общедоступная  строка  toString () {
        вернуть  " Человек { "  +
                " имя = ' "  + имя +  ' \' '  +
                " , семья=' "  + семья +  ' \ ' '  +
                " , возраст = "  + возраст +
                " , пол = "  + пол +
                " , образование= "  + образование +
                ' } ' ;
    }
}
```

Из коллекции объектов `Person` необходимо:
1. Определить количество несовершеннолетних (т.е. людей младше 18 лет).
2. Получить список семей призывников (т.е. мужчин от 18 и до 27 лет).
3. Получить отсортированный по списку предполагаемых вероятностей людей с высшим образованием в выборке (т.е. людей с высшим образованием от 18 до 60 лет для женщин и до 65 лет для мужчин).

##  Реализация
В классе `Main` в функции `main()` необходимо создать коллекцию экземпляров класса `Person` . Вам действительно необходимо большое количество данных. Для примера считаем, что Вы производите перепись населения города Лондона с населением в 10 миллионов человек. Для производства исходных данных воспользуемся следующим способом:
```java
Список< Строка > Имена =  Массивы . asList( " Джек " , " Коннор " , " Гарри " , " Джордж " , " Сэмюэль " , " Джон " );
Список< Строка > семейства =  Массивы . asList( " Эванс " , " Янг " , " Харрис " , " Уилсон " , " Дэвис " , " Адамсон " , " Браун " );
Коллекция< Человек > лица =  новый  ArrayList<> ();
для ( инт я =  0 ; я <  10_000_000 ; я ++ ) {
    лица . добавить( новый  человек (
                имена . получить ( новый  случайный () . nextInt (имена . размер ())),
                семьи . получить ( новый  случайный () . nextInt (семейства . размер ())),
                новый  случайный () . следующийInt( 100 ),
                Секс . значения () [ новый  случайный () . nextInt( Пол.значения () . длина)] ,
                Образование . значения () [ новый  случайный () . nextInt( Образование . значения() . длина)])
    );
}
```

Из созданной коллекции `persons` для каждого задания давайте возьмем новый метод `stream()` и далее предъявляйте к нему непостоянный ряд промежуточных операций и одну терминальную:
1. Для поиска несовершеннолетних використовуйте промежуточный метод `filter()` и терминальный метод `count()` .
2. Для получения списка призывников возможно применение нескольких промежуточных методов `filter()` , а также для преобразования данных из `Person` в `String` (так как нужны только фамилии) використовуйте метод `map()` . Так как требуется получить список `List<String>` терминальным методом будет `collect(Collectors.toList())` .
3. Для получения отсортированного по рейтингу вероятности вероятности людей с высшим уровнем необходимо применить ряд промежуточных методов `filter()` , метод `sorted()` в который нужно положить компаратор по фамилии `Comparator.comparing()` . Завершить стрим необходимо методом `collect()` .
